<!DOCTYPE html>

<html>

  <head>

    <title>Virtual World Framework</title>

    <script type="text/javascript">

      var vwf = {
        models: [ "vwf/model/javascript", "vwf/model/object" ],
         views: [],
      };

    </script>

    <script type="text/javascript" src="../lib/jquery-1.7.1.js"></script>
    <script type="text/javascript" src="../lib/require.js" data-main="../lib/loader"></script>

    <script type="text/javascript" src="qunit.js"></script>

    <script type="text/javascript">

      require( [ "vwf" ], function( kernel ) {

        // Test behavior inheritance.

        kernel.ready( function() {

          asyncTest( "No behaviors", function() {  // Base

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              equal( kernel.execute( baseID, "this.base" ), "base", "base property visible on base" );
              equal( kernel.execute( baseID, "this.baseAccessor" ), "BASE", "base property visible on base through accessor" );

              start();
            } );

          } );

          asyncTest( "Inheritance with no behaviors", function() {  // Derived extends Base

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              equal( kernel.execute( derivedID, "this.derived" ), "derived", "derived property visible on derived" );
              equal( kernel.execute( derivedID, "this.base" ), "base", "base property visible on derived" );

              equal( kernel.execute( derivedID, "this.derivedAccessor" ), "DERIVED", "derived property visible on derived through accessor" );
              equal( kernel.execute( derivedID, "this.baseAccessor" ), "BASE", "base property visible on derived through accessor" );

              start();
            } );

          } );

          asyncTest( "Inheritance through behavior", function() {  // DerivedBaseBehavior implements BaseBehavior extends Base

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              equal( kernel.execute( derivedBaseBehaviorID, "this.derivedBaseBehavior" ), "derivedBaseBehavior", "derived property visible on derived with base behavior" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseBehavior" ), "baseBehavior", "base behavior property visible on derived with base behavior" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.base" ), "base", "base property visible on derived with base behavior" );

              equal( kernel.execute( derivedBaseBehaviorID, "this.derivedBaseBehaviorAccessor" ), "DERIVEDBASEBEHAVIOR", "derived property visible on derived with base behavior through accessor" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseBehaviorAccessor" ), "BASEBEHAVIOR", "base behavior property visible on derived with base behavior through accessor" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseAccessor" ), "BASE", "base property visible on derived with base behavior through accessor" );

              kernel.setProperty( derivedBaseBehaviorID, "derivedBaseBehavior", "UpDaTeD" );
              kernel.setProperty( derivedBaseBehaviorID, "baseBehavior", "UpDaTeD" );
              kernel.setProperty( derivedBaseBehaviorID, "base", "UpDaTeD" );

              equal( kernel.execute( derivedBaseBehaviorID, "this.derivedBaseBehavior" ), "UpDaTeD", "derived property after initialization on derived with base behavior" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseBehavior" ), "UpDaTeD", "base behavior property after initialization on derived with base behavior" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.base" ), "UpDaTeD", "base property after initialization on derived with base behavior" );

              equal( kernel.execute( derivedBaseBehaviorID, "this.derivedBaseBehaviorAccessor" ), "UPDATED", "derived property after initialization on derived with base behavior through accessor" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseBehaviorAccessor" ), "UPDATED", "base behavior property after initialization on derived with base behavior through accessor" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseAccessor" ), "UPDATED", "base property after initialization on derived with base behavior through accessor" );

              start();
            } );

          } );

          asyncTest( "Inheritance through two behaviors", function() {  // DerivedBaseBehaviorOtherBehavior implements BaseBehavior, OtherBehavior extends Base

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.derivedBaseBehaviorOtherBehavior" ), "derivedBaseBehaviorOtherBehavior", "derived property visible on derived with base and other behaviors" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.baseBehavior" ), "baseBehavior", "base behavior property visible on derived with base and other behaviors" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.otherBehavior" ), "otherBehavior", "other behavior property visible on derived with base and other behaviors" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.base" ), "base", "base property visible on derived with base and other behaviors" );

              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.derivedBaseBehaviorOtherBehaviorAccessor" ), "DERIVEDBASEBEHAVIOROTHERBEHAVIOR", "derived property visible on derived with base and other behaviors through accessor" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.baseBehaviorAccessor" ), "BASEBEHAVIOR", "base behavior property visible on derived with base and other behaviors through accessor" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.otherBehaviorAccessor" ), "OTHERBEHAVIOR", "other behavior property visible on derived with base and other behaviors through accessor" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.baseAccessor" ), "BASE", "base property visible on derived with base and other behaviors through accessor" );

              kernel.setProperty( derivedBaseBehaviorOtherBehaviorID, "derivedBaseBehaviorOtherBehavior", "UpDaTeD" );
              kernel.setProperty( derivedBaseBehaviorOtherBehaviorID, "baseBehavior", "UpDaTeD" );
              kernel.setProperty( derivedBaseBehaviorOtherBehaviorID, "otherBehavior", "UpDaTeD" );
              kernel.setProperty( derivedBaseBehaviorOtherBehaviorID, "base", "UpDaTeD" );

              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.derivedBaseBehaviorOtherBehavior" ), "UpDaTeD", "derived property after initialization on derived with base and other behaviors" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.baseBehavior" ), "UpDaTeD", "base behavior property after initialization on derived with base and other behaviors" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.otherBehavior" ), "UpDaTeD", "other behavior property after initialization on derived with base and other behaviors" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.base" ), "UpDaTeD", "base property after initialization on derived with base and other behaviors" );

              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.derivedBaseBehaviorOtherBehaviorAccessor" ), "UPDATED", "derived property after initialization on derived with base and other behaviors through accessor" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.baseBehaviorAccessor" ), "UPDATED", "base behavior property after initialization on derived with base and other behaviors through accessor" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.otherBehaviorAccessor" ), "UPDATED", "other behavior property after initialization on derived with base and other behaviors through accessor" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.baseAccessor" ), "UPDATED", "base property after initialization on derived with base and other behaviors through accessor" );

              start();
            } );

          } );

          asyncTest( "Inheritance through behavior with own inheritance", function() {  // DerivedDerivedBehavior implements DerivedBehavior extends Base; DerivedBehavior extends BaseBehavior

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedDerivedBehavior" ), "derivedDerivedBehavior", "derived property visible on derived with derived behavior" );
              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedBehavior" ), "derivedBehavior", "derived behavior property visible on derived with derived behavior" );
              equal( kernel.execute( derivedDerivedBehaviorID, "'baseBehavior' in this" ), false, "base behavior property not visible on derived with derived behavior (JavaScript binding)" );
              equal( kernel.getProperty( derivedDerivedBehaviorID, "baseBehavior" ), undefined, "base behavior property not visible on derived with derived behavior (kernel delegation)" );
              equal( kernel.execute( derivedDerivedBehaviorID, "this.base" ), "base", "base property visible on derived with derived behavior" );

              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedDerivedBehaviorAccessor" ), "DERIVEDDERIVEDBEHAVIOR", "derived property visible on derived with derived behavior through accessor" );
              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedBehaviorAccessor" ), "DERIVEDBEHAVIOR", "derived behavior property visible on derived with derived behavior through accessor" );
              equal( kernel.execute( derivedDerivedBehaviorID, "'baseBehaviorAccessor' in this" ), false, "base behavior property not visible on derived with derived behavior through accessor (JavaScript binding)" );
              // equal( kernel.getProperty( derivedDerivedBehaviorID, "baseBehaviorAccessor" ), undefined, "base behavior property not visible on derived with derived behavior through accessor (kernel delegation)" );  // TODO: would need to handle ignorePrototype in kernel.model.javascript.gettingProperty() to prevent accessor inheritance in behaviors
              equal( kernel.execute( derivedDerivedBehaviorID, "this.baseAccessor" ), "BASE", "base property visible on derived with derived behavior through accessor" );

              kernel.setProperty( derivedDerivedBehaviorID, "derivedDerivedBehavior", "UpDaTeD" );
              kernel.setProperty( derivedDerivedBehaviorID, "derivedBehavior", "UpDaTeD" );
              kernel.setProperty( derivedDerivedBehaviorID, "baseBehavior", "CrEaTeD" );
              kernel.setProperty( derivedDerivedBehaviorID, "base", "UpDaTeD" );

              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedDerivedBehavior" ), "UpDaTeD", "derived property after initialization on derived with derived behavior" );
              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedBehavior" ), "UpDaTeD", "derived behavior property after initialization on derived with derived behavior" );
              equal( kernel.execute( derivedDerivedBehaviorID, "'baseBehavior' in this" ), true, "base behavior property created on derived with derived behavior (JavaScript binding)" );  // TODO: kernel doesn't prevent this yet
              equal( kernel.getProperty( derivedDerivedBehaviorID, "baseBehavior" ), "CrEaTeD", "base behavior property created on derived with derived behavior (kernel delegation)" );  // TODO: kernel doesn't prevent this yet
              equal( kernel.execute( derivedDerivedBehaviorID, "this.base" ), "UpDaTeD", "base property after initialization on derived with derived behavior" );

              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedDerivedBehaviorAccessor" ), "UPDATED", "derived property after initialization on derived with derived behavior through accessor" );
              equal( kernel.execute( derivedDerivedBehaviorID, "this.derivedBehaviorAccessor" ), "UPDATED", "derived behavior property after initialization on derived with derived behavior through accessor" );
              equal( kernel.execute( derivedDerivedBehaviorID, "'baseBehaviorAccessor' in this" ), false, "base behavior property not initialized on derived with derived behavior through accessor (JavaScript binding)" );
              // equal( kernel.getProperty( derivedDerivedBehaviorID, "baseBehaviorAccessor" ), undefined, "base behavior property not initialized on derived with derived behavior through accessor (kernel delegation)" );  // TODO: would need to handle ignorePrototype in kernel.model.javascript.gettingProperty() to prevent accessor inheritance in behaviors
              equal( kernel.execute( derivedDerivedBehaviorID, "this.baseAccessor" ), "UPDATED", "base property after initialization on derived with derived behavior through accessor" );

              start();
            } );

          } );

          asyncTest( "Multiple behavior inheritance order", function() {  // DerivedBaseBehaviorOtherBehavior implements BaseBehavior, OtherBehavior extends Base

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              kernel.createProperty( derivedBaseBehaviorOtherBehaviorID, "a", "derivedBaseBehaviorOtherBehavior" );

              kernel.createProperty( baseBehaviorID, "a", "baseBehavior" );
              kernel.createProperty( baseBehaviorID, "b", "baseBehavior" );

              kernel.createProperty( otherBehaviorID, "a", "otherBehavior" );
              kernel.createProperty( otherBehaviorID, "b", "otherBehavior" );
              kernel.createProperty( otherBehaviorID, "c", "otherBehavior" );

              kernel.createProperty( baseID, "a", "base" );
              kernel.createProperty( baseID, "b", "base" );
              kernel.createProperty( baseID, "c", "base" );
              kernel.createProperty( baseID, "d", "base" );

              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.a" ), "derivedBaseBehaviorOtherBehavior", "derived property visible above behaviors and prototype" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.b" ), "baseBehavior", "second behavior property visible above first behavior and prototype" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.c" ), "otherBehavior", "first behavior property visible above prototype" );
              equal( kernel.execute( derivedBaseBehaviorOtherBehaviorID, "this.d" ), "base", "prototype property visible" );

              start();
            } );

          } );

          asyncTest( "Self-targeted event listeners on behaviors", function() {

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              kernel.fireEvent( derivedBaseBehaviorID, "derivedBaseBehavior" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.derivedBaseBehavior" ), "derivedBaseBehaviorEvent", "derived listener invoked on derived" );

              kernel.fireEvent( derivedBaseBehaviorID, "baseBehavior" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.baseBehavior" ), "baseBehaviorEvent", "base behavior listener invoked on derived" );
              equal( kernel.execute( baseBehaviorID, "this.baseBehavior" ), "baseBehavior", "base behavior listener not invoked on base behavior" );

              kernel.fireEvent( derivedBaseBehaviorID, "base" );
              equal( kernel.execute( derivedBaseBehaviorID, "this.base" ), "baseEvent", "base listener invoked on derived" );
              equal( kernel.execute( baseID, "this.base" ), "base", "base listener not invoked on base" );

              start();
            } );

          } );

          asyncTest( "Method and event updates on behavior proxy", function() {

            createFixture( function( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                derivedBehaviorID, baseBehaviorID, otherBehaviorID ) {

              kernel.execute( derivedBaseBehaviorID, "Object.getPrototypeOf( this ).methods.baseBehavior = function() { this.properties.baseBehavior = 'baseBehaviorMethod' }" );
              kernel.execute( baseBehaviorID, "this.methods.baseBehavior()" );
              equal( kernel.execute( baseBehaviorID, "this.properties.baseBehavior" ), "baseBehaviorMethod", "method set on proxy updated the behavior" );

              kernel.execute( baseBehaviorID, "this.events.baseBehavior = this.events.flush( this )" );
              kernel.execute( derivedBaseBehaviorID, "Object.getPrototypeOf( this ).events.baseBehavior = function() { this.properties.baseBehavior = 'baseBehaviorEvent' }" );
              kernel.execute( baseBehaviorID, "this.events.baseBehavior()" );
              equal( kernel.execute( baseBehaviorID, "this.properties.baseBehavior" ), "baseBehaviorEvent", "event add on proxy updated the behavior" );

              start();
            } );

          } );

          // == Helper functions =====================================================================

          // Create nodes in this arrangement:
          // 
          //   - DerivedBaseBehavior implements BaseBehavior extends Base
          //   - DerivedBaseBehaviorOtherBehavior implements BaseBehavior, OtherBehavior extends Base
          //   - DerivedDerivedBehavior implements DerivedBehavior extends Base
          //   
          //   - Derived extends Base
          //   - Base
          //   
          //   - DerivedBehavior extends BaseBehavior
          //   - BaseBehavior
          //   
          //   - OtherBehavior

          function createFixture( callback ) {

            createNode( "otherBehavior", undefined, undefined, function( otherBehaviorID ) {
              createNode( "baseBehavior", undefined, undefined, function( baseBehaviorID ) {
                createNode( "derivedBehavior", undefined, baseBehaviorID, function( derivedBehaviorID ) {
                  createNode( "base", undefined, undefined, function( baseID ) {
                    createNode( "derived", undefined, baseID, function( derivedID ) {
                      createNode( "derivedBaseBehavior", [ baseBehaviorID ], baseID, function( derivedBaseBehaviorID ) {
                        createNode( "derivedBaseBehaviorOtherBehavior", [ otherBehaviorID, baseBehaviorID ], baseID, function( derivedBaseBehaviorOtherBehaviorID ) {
                          createNode( "derivedDerivedBehavior", [ derivedBehaviorID ], baseID, function( derivedDerivedBehaviorID ) {
                            callback( derivedID, derivedBaseBehaviorID, derivedBaseBehaviorOtherBehaviorID, derivedDerivedBehaviorID, baseID,
                              derivedBehaviorID, baseBehaviorID, otherBehaviorID );
                          } );
                        } );
                      } );
                    } );
                  } );
                } );
              } );
            } );
  
          }

          // Create a node with the given prototype and behaviors and a property of the given name
          // having that same name as its value. A second property wraps the first property using
          // accessor methods that convert to upper case on get and to lower case on set.

          function createNode( which, behaviors, prototype, callback /* nodeID */ ) {

            var descriptor = {
              properties: {},
              methods: {},
              events: {},
              scripts: [],
            };

            descriptor.extends = prototype;
            descriptor.implements = behaviors;

            descriptor.properties[which] = which;

            descriptor.properties[which+"Accessor"] = {
              get: "return this." + which + ".toUpperCase()",
              set: "this." + which + " = value.toLowerCase()",
            };

            descriptor.methods[which] = null;
            descriptor.events[which] = null;

            descriptor.scripts.push(
              "this.initialize = function() { " +
                "this.events." + which + " = function() { this.properties." + which + " = '" + which + "Event' } " +
              "}"
            );

            kernel.createNode( descriptor, callback );
          }

        } );

      } );

    </script>

    <link rel="stylesheet" type="text/css" href="qunit.css" />

  </head>

  <body>

    <h1 id="qunit-header">Virtual World Framework</h1>
    <h2 id="qunit-banner"></h2>
    <div id="qunit-testrunner-toolbar"></div>
    <h2 id="qunit-userAgent"></h2>
    <ol id="qunit-tests"></ol>

    <div id="qunit-fixture">test markup, will be hidden</div>

  </body>

</html>
