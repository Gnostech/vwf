# Copyright 2012 United States Government, as represented by the Secretary of Defense, Under
# Secretary of Defense (Personnel & Readiness).
# 
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
# in compliance with the License. You may obtain a copy of the License at
# 
#   http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.
---

extends: http://vwf.example.com/node3.vwf
properties:
  scale: [ 1, 1, 1]
  lookAngle: 0.0
  rel_x: 0
  rel_y: 0
  last_x: 0
  last_y: 0
  position: 
    set: |
           this.translation = value;
           this.position = value;
           //this.updateCamera();
  orientation:
    set: |
           this.orientation = value;
           this.rotation = value;
           //this.updateCamera();    
  RotationAmt:
  Controlled:
  Health: 100
  steerAmt:
    set: |
           this.steerAmt = value;
           this.steerAmt = Math.min(.7,Math.max(-.7,value));
           
  wheelRotate:
    set: |
            this.wheelRotate = value;
            
            
events:
  pointerMove:            
methods:
  update:
  fire: 
  hit:
  localKeyDown:
  localKeyUp:
  localpointerMove:
scripts: 
- |
        function loadjscssfile(filename, filetype){
         if (filetype=="js"){ //if filename is a external JavaScript file
          var fileref=document.createElement('script')
          fileref.setAttribute("type","text/javascript")
          fileref.setAttribute("src", filename)
         }
         else if (filetype=="css"){ //if filename is an external CSS file
          var fileref=document.createElement("link")
          fileref.setAttribute("rel", "stylesheet")
          fileref.setAttribute("type", "text/css")
          fileref.setAttribute("href", filename)
         }
         if (typeof fileref!="undefined")
          document.getElementsByTagName("head")[0].appendChild(fileref)
        }
         this.initialize = function() {
                
               
            //    if(!this.PlayerNumber)
            //    {
            //       
                    loadjscssfile('terrainheight.js','js')
                    loadjscssfile('terrainfunctions.js','js')
           //         return;
            //    }
                    
                
               
                
                this.position = [0,0,0];
                this.updatecounter = 0;
               
                
                this.numfired = 0;
                this.steerAmt = 1.0;
                this.wheelRotate = 0.0;
                this.RotationAmt = 0.0;
                this.GetSteer = function(){return this.steerAmt;}
                this.wheelRotMatrix = [];
                this.WDown = false;
                this.SDown = false;
                this.DDown = false;
                this.ADown = false;
                this.Momentum = 0.0;
                this.lookAngle = 0.0;
                
                this.Controlled = false;
                
                if(this.initialPos)
                {
                      this.translation = this.initialPos;
                }
                if(this.initialRot)
                    this.rotation = this.intiailRot;
                if(this.initialHealth)
                    this.Health = this.initialHealth;  
                    
                if(this.initialRotAmt) this.RotationAmt = this.initialRotAmt;
                if(this.initialSteerAmt) this.steerAmt = this.initialSteerAmt;
                if(this.initialWheelRotate) this.wheelRotate = this.initialWheelRotate;
                
                this.future(.02).update();
         }
         
         

         this.localpointerMove = function( parms ){

              
              if(this.rel_x == undefined) return;
              this.rel_x = this.last_x - parms.clientX;
              this.rel_y = this.last_y - parms.clientY;
              this.lookAngle += this.rel_x/300;
               this.last_x = parms.clientX;
                this.last_y = parms.clientY;
         }
      
         this.hit = function()
         {
             this.Health -= 25;
             
                if(this.Health < 1)
                {
                 this.SceneDestroy();
                 //LogFailure();
                 
                }
             
                 
         }
         this.fire = function()
         {
                goog.vec.Mat4.fromAngleAxis = function(angle,axis){ var quat = goog.vec.Quaternion.fromAngleAxis(angle,axis,[]); return goog.vec.Quaternion.toRotationMatrix4(quat,[]);} ;
                this.numfired++;
                var proto = { 
                   
                    extends: 'http://vwf.example.com/node3.vwf',
                    source: 'missile.dae',
                    type: 'model/vnd.collada+xml',
                    properties: {
                        translation: [10,10,10],
                        rotation: [1,0,0,90],
                        position: {set:"this.translation = value; this.position = value; this.updateCamera();"},
                        orientation: {set:"this.rotation = value; this.orientation = value; this.updateCamera();"},
                        shooter: "",
                        targetpoint: null,
                        age: 0
                        },
                    methods: { 
                        updatestep: null,
                        tick: null
                        },
                    scripts: [  " goog.vec.Mat4.fromAngleAxis = function(angle,axis){ var quat = goog.vec.Quaternion.fromAngleAxis(angle,axis,[]); return goog.vec.Quaternion.toRotationMatrix4(quat,[]);} ;"+
                                "this.initialize = function() {"+
                                "  "+
                                "this.active = true;"+
                                //This seems odd as well. I don't think the properties are being initialized.
                               // "this.translation = window.vwf.getNode(this.id).properties.translation;"+
                               // "this.rotation = window.vwf.getNode(this.id).properties.rotation;"+
                                //"this.target = this.GetNearist();"+
                                //"this.targetpoint = null;"+
                                //"if(this.target) {this.targetpoint = this.target.translation;}"+
                                //"this.future(1.0/60.0).updatestep(); "+
                                "}",
                                "this.tick = function(){    \n"+
                                "\n"+
                                "this.age++;\n"+
                                "if(this.age > 200) this.delete();\n"+
                                "if(this.translation[2] < document.TerrainFunctions.SampleTerrainByPos(this.translation[0],this.translation[1]))\n this.delete();\n"+
                                "var front = goog.vec.Mat4.multVec3(goog.vec.Mat4.fromAngleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[0,0,-.35],[]);\n"+
                                "this.translation=       [this.translation[0] + front[0],  \n"+
                                "                            this.translation[1] + front[1],  \n"+
                                "                            this.translation[2]+ front[2]]; \n"+
                                "var testpoint;\n"+
                                "this.target = this.parent.children[this.targetid];"+
                                "if (this.target) testpoint = [this.target.translation[0],this.target.translation[1],this.target.translation[2]];\n"+
                               
                                "if(testpoint){\n"+
                                "testpoint[2] += 2;\n"+
                                "var dist = goog.vec.Vec3.distance(this.translation, testpoint);\n"+
                               
                                "if(dist < 40 && this.active==true)"+
                                "{"+
                                "    var pointfront = [0,0,-1];"+
                                "    var to = goog.vec.Vec3.subtract(testpoint,this.translation,[]);"+
                                "    to = document.TerrainFunctions.normalize(to);"+
                                "    var a = goog.vec.Vec3.cross(pointfront,to,[]);"+
                                "    var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + goog.vec.Vec3.dot(pointfront,to,[]) );    "+
                                "    var angle = 0; var axis = [0,0,1];"+
                                "    var  tofront_norm = [];"+
                                "    goog.vec.Quaternion.normalize(tofront,tofront_norm);    "+
                                "    var currentrot = [];"+
                                "    goog.vec.Quaternion.fromAngleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]],currentrot);"+
                                "    var slerped_rot = [];"+
                                "    goog.vec.Quaternion.slerp(currentrot,tofront_norm,.02,slerped_rot);"+
                                "    angle = goog.vec.Quaternion.toAngleAxis(slerped_rot,axis);"+
                                "    this.rotation = [axis[0],axis[1],axis[2],angle/0.0174532925];   "+
                                "}"+
                                "if(dist < 3 && this.active==true) {this.hit();}"+
                                "}"+ 
                                //"this.future(1.0/60.0).updatestep();"+
                                
                                "}",
                                "this.delete = function(){this.active=false; this.parent.children.delete(this);}",
                                "this.hit = function() {debugger;this.target.hit();this.delete();}"
                                ]    
                };
               
                
               //Set the missile initial position
                //proto.properties.translation[0] = this.translation[0];
                //proto.properties.translation[1] = this.translation[1];
                //proto.properties.translation[2] = this.translation[2] + 4;
                
                //rotate the missile to face the front of the humvee
                var modelmatrix = this.turret.getModelMatrix();
                 var tempmodelmatrix = [];
                 for(var i=0; i< 16; i++)
                  tempmodelmatrix[i] = modelmatrix[i];
                tempmodelmatrix[3] = 0;
                tempmodelmatrix[7] = 0;
                tempmodelmatrix[11] = 0;
                tempmodelmatrix = goog.vec.Mat4.transpose(tempmodelmatrix,[]);
                var forward = goog.vec.Mat4.multVec3(tempmodelmatrix,[0,1,0],[]);
                var missilerotation = [];
                var pointfront = [0,0,-1];
                var to = forward;
                to = document.TerrainFunctions.normalize(to);
                var a = goog.vec.Vec3.cross(pointfront,to,[]);
                var tofront = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + goog.vec.Vec3.dot(pointfront,to) );    
                var angle = 0; var axis = [0,0,1];
                var  tofront_norm = [];
                goog.vec.Quaternion.normalize(tofront,tofront_norm);    
                var currentrot = [];
               
                var tmatrix = goog.vec.Quaternion.toRotationMatrix4(tofront_norm,[]);
                missilerotation = [axis[0],axis[1],axis[2],angle/0.0174532925];   
                tmatrix[12] = this.translation[0];
                tmatrix[13] = this.translation[1];
                tmatrix[14] = this.translation[2]+4;
                proto.properties.transform = tmatrix;
            //    proto.properties.rotation[0] = missilerotation[0];
            //    proto.properties.rotation[1] = missilerotation[1];
            //    proto.properties.rotation[2] = missilerotation[2];
            //    proto.properties.rotation[3] = missilerotation[3];
                proto.properties.shooter = this.PlayerNumber;
                proto.properties.targetpoint = this.GetNearist();
                proto.properties.targetid = proto.properties.targetpoint[1];
                proto.properties.targetpoint = proto.properties.targetpoint[0];
                var newid = "missile" + this.numfired + "" + this.PlayerNumber;
                console.log(newid);
               // this.camtarget = newid;
               // proto.uri = newid;
               // proto.id = newid;
               
                this.parent.children.create(newid,proto);
                //vwf_view.kernel.kernel.createNode(proto, null);
                
         }
        this.GetNearist = function() 
        { 
            
            var dot = -1;
            var pos = null;
            var nodename = '';
            for(var node in this.parent.children)
            { 
                var lnode = this.parent.children[node];
                if(lnode.PlayerNumber && lnode.PlayerNumber != this.PlayerNumber)
                {
                   var thisdir = goog.vec.Vec3.subtract(lnode.translation,this.translation,[]);
                    thisdir = document.TerrainFunctions.normalize(thisdir);
                    var front = goog.vec.Mat4.multVec3(goog.vec.Mat4.fromAngleAxis(this.rotation[3]*0.0174532925,[this.rotation[0],this.rotation[1],this.rotation[2]]),[0,0,-1],[]);
                   var thisdot = goog.vec.Vec3.dot(thisdir,front,[]);
                   if(thisdot > dot){dot = thisdot; pos = lnode.translation; nodename = lnode.name;}
                }
            }
            return [pos,nodename];
        }
         this.turn = function(dir)
         {
            var t = this.RotationAmt + dir * this.steerAmt/16.0 * .03 * this.Momentum;
            //vwf_view.kernel.setProperty(this.id, "RotationAmt", t);
            this.RotationAmt = t;
         }
         
         this.localKeyUp = function(e)
         {
                    
            if(e == 'A')
                 this.ADown = false;
            if(e == 'S')
                 this.SDown = false;
            if(e == 'D')
                 this.DDown = false;
            if(e == 'W')
                 this.WDown = false;                 
         }
         this.localKeyDown = function(e)
         {
            if(e == 'A')
                 this.ADown = true;
            if(e == 'S')
                 this.SDown = true;
            if(e == 'D')
                 this.DDown = true;
            if(e == 'W')
                 this.WDown = true;                 
         }
         this.update = function(){
         
            //if(document["MY_HMVEE"] == this)
            {
                  
                  //vwf_view.kernel.setProperty(this.id, "steerAmt", this.steerAmt *.993);
                  this.steerAmt = this.steerAmt * .993;
                  this.Momentum *= .993;
                 
                  if(this.SDown == true || this.WDown == true)this.lookAngle *= Math.min(1.0,Math.max(0.0,1.0/(1.0+Math.abs(this.Momentum)/600)));
                  if(this.ADown == true) this.steerAmt +=.03
                  if(this.DDown == true) this.steerAmt -=.03
                  
                  if(this.WDown == true) this.Momentum += .2;
                  if(this.SDown == true) this.Momentum -= .2;
                 
                  //build quaternion to rotate from local up to terrain normal
                  var norm = [0,0,1];
                  if(document.TerrainFunctions)
                    norm = document.TerrainFunctions.SampleNormalByPos(this.translation[0],this.translation[1]);
                  var up = [0,0,1];
                  if(document.TerrainFunctions)
                    norm = document.TerrainFunctions.normalize(norm);
                  if(document.TerrainFunctions)
                     up = document.TerrainFunctions.normalize(up);
                  var a = goog.vec.Vec3.cross(up,norm,goog.vec.Vec3.create());
                  var tonorm = goog.vec.Quaternion.createFromValues( a[0], a[1], a[2], 1 + goog.vec.Vec3.dot(up,norm) );
                  var  current = [];
                  goog.vec.Quaternion.normalize(tonorm,current);
                 
                 
                  var turn = goog.vec.Quaternion.createFromValues( 0, 0, 0, 1 );
                  goog.vec.Quaternion.fromAngleAxis(this.RotationAmt,norm, turn);
                 
                 
                  var totalquat = goog.vec.Quaternion.createFromValues( 0, 0, 0, 1 );
                  goog.vec.Quaternion.concat(turn,current, totalquat);
                  var axis = [0,0,0];
                  var angle = 0;
                  angle = goog.vec.Quaternion.toAngleAxis(totalquat,axis);
                  //vwf_view.kernel.setProperty(this.id, 'orientation' , [axis[0],axis[1],axis[2],angle/0.0174532925]);
                  this.rotation = [axis[0],axis[1],axis[2],angle/0.0174532925];
                  var z = 0.0;
                  if(document.TerrainFunctions)
                    z = document.TerrainFunctions.SampleTerrainByPos(this.translation[0],this.translation[1]);
                    
                 
                  //vwf_view.kernel.setProperty(this.id, 'wheelRotate',this.wheelRotate -.01 * this.Momentum);
                  this.wheelRotate=this.wheelRotate +.01 * this.Momentum;
                      
                  var q1 = goog.vec.Quaternion.fromAngleAxis(angle,axis,[0,0,0,0]);  
                  var q1mat = goog.vec.Quaternion.toRotationMatrix4(q1,goog.vec.Mat4.create());
                  var front = goog.vec.Mat4.multVec3(q1mat,[0,1,0],[0,0,0]);
                  var flat = [0,0,1];
                  var slope = goog.vec.Vec3.dot(front,flat);
                
                  this.Momentum += (slope*.25);
                  var speedforward  =-this.Momentum*.007;  
                  
                  front = goog.vec.Vec4.scale(front,speedforward,[0,0,0]);
                  //vwf_view.kernel.setProperty(this.id, 'position' , [this.position[0] + front[0],this.position[1] + front[1],z + front[2]]);
                  this.translation = [this.translation[0] + front[0],this.translation[1] + front[1],z + front[2]]   
                  this.turn(-1);
                      
                 
                  
                  this.updatecounter++;
                  if(this.updatecounter > 300)
                  {
                   //  vwf_view.kernel.setProperties(this.id,{'translation':this.translation,'rotation':this.rotation,'RotationAmt':this.RotationAmt},0,null);
                   //  vwf_view.kernel.setProperty(this.id,'rotation',this.rotation,0,null);
                   //  vwf_view.kernel.setProperty(this.id,'RotationAmt',this.RotationAmt,0,null);
                        this.updatecounter = 0;
                  }
              }
              
            this.future(1.0/60.0).update();
                 
         }
         
        this.SceneDestroy = function()
        {
           // var parms = new Array();
           // parms.push(document[document.PlayerNumber +'link'].id);
            //alert(JSON.stringify(parms));
           // vwf_view.kernel.callMethod('index-vwf','deleteplayer',parms);
           this.parent.children.delete(this);
        }
         var that = this;
       
        